import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

const initialState = {
    network: "eth",
    userAddress: ""
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const connectToProvider = createAsyncThunk(
    'network/connectToProvider',
    async () => {
        let request = await window.ethereum.request({ method: 'eth_requestAccounts' });
        return request[0];
    }
);

export const networkSlice = createSlice({
    name: 'networkSlice',
    initialState,
    reducers: {
        selectNetwork: (state, action) => {
            state.network = action.payload.network;
        },
        setAddress: (state, action) => {
            state.userAddress = action.payload.userAddress
        }
    },
    //   The `extraReducers` field lets the slice handle actions defined elsewhere,
    //   including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(connectToProvider.fulfilled, (state, action) => {
                state.userAddress = action.payload;
            });
    },
});

export const { selectNetwork, setAddress } = networkSlice.actions;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd = (amount) => (dispatch, getState) => {
//   const currentValue = selectCount(getState());
//   if (currentValue % 2 === 1) {
//     dispatch(incrementByAmount(amount));
//   }
// };

export default networkSlice.reducer;
